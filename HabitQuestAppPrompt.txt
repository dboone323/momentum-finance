Act as a principal software architect and expert game developer. Your specialization is in Swift, SwiftUI, and designing deeply engaging gamification mechanics for mobile applications.Your task is to generate the complete foundational boilerplate for a gamified habit tracker named "HabitQuest". The generated code should be production-quality, scalable, and serve as a robust template for future development.The architecture must be modular and test-driven, using SwiftUI and MVVM. The app will be structured around a main TabView, with each tab representing a core feature module. All code should be clearly documented.Project Brief: HabitQuest1. Vision & Core Game LoopApp Name: HabitQuestCore Loop: Users define real-world habits as in-game "Quests." Completing a Quest awards Experience Points (XP). Gaining enough XP allows the user's character to Level Up. This positive feedback loop is designed to make building routines fun and motivating.Target Platform: iOS (with a multi-platform strategy in mind for the future).Multi-Platform Strategy: Shared Core Logic (Models, ViewModels, Services), Separate UI per platform.2. Requested File & Folder StructurePlease generate the code organized into the following folder structure. This structure is non-negotiable and serves as the template for the project.HabitQuest/
├── HabitQuestApp.swift         # App Entry Point
│
├── Application/                # Core App Logic & Setup
│   ├── AppMainView.swift       # Main view with TabView
│   └── HabitQuestApp.swift
│
├── Core/
│   ├── Models/                 # SwiftData Models
│   │   ├── Habit.swift
│   │   ├── HabitLog.swift
│   │   └── PlayerProfile.swift
│   │
│   ├── Services/               # Business Logic & Services
│   │   └── GameRules.swift
│   │
│   └── Utilities/              # App-wide Helpers
│       ├── Logger.swift
│       └── ErrorHandler.swift
│
├── Features/                   # Feature Modules
│   │
│   ├── TodaysQuests/
│   │   ├── TodaysQuestsView.swift
│   │   └── TodaysQuestsViewModel.swift
│   │
│   ├── CharacterProfile/
│   │   ├── ProfileView.swift
│   │   └── ProfileViewModel.swift
│   │
│   └── QuestLog/
│       ├── QuestLogView.swift
│       └── QuestLogViewModel.swift
│
├── Tests/
│   ├── HabitQuestUnitTests/
│   │   ├── ViewModels/
│   │   │   └── TodaysQuestsViewModelTests.swift
│   │   └── Services/
│   │       └── GameRulesTests.swift
│   │
│   └── HabitQuestUITests/
│       └── TabNavigationUITests.swift
│
└── Supporting Files/
    ├── .gitignore
    ├── .swiftlint.yml
    └── verify-project.sh
3. Data Layer (SwiftData Models)Generate the following SwiftData @Model classes. Ensure they are well-documented.Habit.swift: Represents a single habit or "quest."id: UUID (primary key)name: StringhabitDescription: Stringfrequency: enum (daily, weekly)creationDate: DatexpValue: Intstreak: Int (current streak for this specific habit)logs: [HabitLog]? (one-to-many relationship, cascade delete)HabitLog.swift: A timestamped record of a habit's completion.completionDate: Datehabit: Habit? (one-to-one relationship back to the parent)PlayerProfile.swift: Tracks the user's global progress.Design Note: This should not be a technical singleton. Instead, the architecture should ensure only one instance is ever created and fetched from the SwiftData ModelContext.level: Int (default: 1)currentXP: Int (default: 0)xpForNextLevel: Int (default: 100)longestStreak: Int (tracks the highest overall streak across all habits)4. Core Logic & Feature Modules (MVVM)For each feature module, generate a View and its corresponding ViewModel. The Views should be simple placeholders, but the ViewModels should define the necessary properties and methods to fulfill their roles.GameRules.swift (Service)A struct containing static, pure functions for game logic.Include static func calculateXPForNextLevel(forLevel level: Int) -> Int. Use a simple exponential curve, e.g., 100 * pow(1.5, Double(level - 1)).Include static func processHabitCompletion(habit: Habit, profile: PlayerProfile) which contains the logic for awarding XP, checking for level-ups, and updating streaks.TodaysQuestsView.swift / TodaysQuestsViewModel.swiftViewModel: Must be able to fetch and display Habit entities due today. It needs logic to filter habits based on their frequency and last completion date from their logs.Expose a function: func completeHabit(_ habit: Habit) that uses GameRules to update the player's profile and save the changes.ProfileView.swift / ProfileViewModel.swiftViewModel: Fetches the single PlayerProfile instance.Expose properties for level, xpProgress (a Float between 0.0 and 1.0), currentXP, xpForNextLevel, and longestStreak for the View to bind to.QuestLogView.swift / QuestLogViewModel.swiftViewModel: Fetches and displays all Habit entities.Expose functions for addHabit(), deleteHabit(), and updateHabit().5. Testing & Quality AssuranceProvide boilerplate for tests that establish a testing pattern.GameRulesTests.swift (Unit Test): Write a test to verify the calculateXPForNextLevel function works for levels 1, 2, and 10.TodaysQuestsViewModelTests.swift (Unit Test): Write a placeholder test class that can be expanded later. Include comments on what to mock (e.g., the SwiftData model container).TabNavigationUITests.swift (UI Test): Write a simple UI test that launches the app and verifies that tapping on each tab bar item correctly navigates to the corresponding view..swiftlint.yml: Generate a comprehensive SwiftLint configuration file with a robust set of rules enabled (e.g., line_length, trailing_whitespace, force_cast, unused_closure_parameter).6. Project & Build Management.gitignore: Generate a standard, comprehensive .gitignore file suitable for Swift/Xcode projects, including rules for user data, dependencies (CocoaPods, Carthage, SPM), and build artifacts.verify-project.sh: A shell script to automate verification.It must use set -e and set -o pipefail.It must build and test the "HabitQuest" scheme for iOS.It must run SwiftLint and fail the script if lint violations are found.7. Expert Analysis & RecommendationsAfter generating the code, please provide your expert analysis in a separate block.Key Gamification Challenge: What is the single biggest challenge in balancing the progression for "HabitQuest"? Briefly explain your recommended approach to tuning the XP curve and rewards.Implementation Order: In what order should a developer build out the full logic for these modules to create a playable, testable loop as quickly as possible?Making it "Juicy": Suggest 2-3 specific, high-impact animation or haptic feedback ideas to make the user experience feel satisfying. Focus on the quest completion and level-up moments.