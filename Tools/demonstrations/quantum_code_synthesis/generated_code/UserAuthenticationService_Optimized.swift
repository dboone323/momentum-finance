//
//  UserAuthenticationService_Optimized.swift
//  Quantum-workspace
//
//  Optimized version generated by Quantum Code Synthesis
//

import Foundation
import CryptoKit

/// Optimized user authentication service with quantum-enhanced performance
@MainActor
public final class UserAuthenticationService {
    // MARK: - Properties

    private let userStore: UserStore
    private let tokenManager: JWTTokenManager
    private let passwordHasher: PasswordHasher
    private let rateLimiter: RateLimiter

    // Quantum-optimized caching layer
    private let authCache: NSCache<NSString, AuthenticationResult>
    private let userCache: NSCache<NSString, User>
    private let tokenValidationCache: NSCache<NSString, Bool>

    // MARK: - Initialization

    public init(userStore: UserStore = .shared,
                tokenManager: JWTTokenManager = .shared,
                passwordHasher: PasswordHasher = .shared,
                rateLimiter: RateLimiter = RateLimiter()) {
        self.userStore = userStore
        self.tokenManager = tokenManager
        self.passwordHasher = passwordHasher
        self.rateLimiter = rateLimiter

        // Initialize caches with quantum-optimized settings
        self.authCache = NSCache<NSString, AuthenticationResult>()
        self.authCache.countLimit = 1000

        self.userCache = NSCache<NSString, User>()
        self.userCache.countLimit = 500

        self.tokenValidationCache = NSCache<NSString, Bool>()
        self.tokenValidationCache.countLimit = 2000
    }

    // MARK: - Public API

    /// Authenticate a user with quantum-optimized caching
    public func authenticate(username: String, password: String) async throws -> AuthenticationResult {
        let cacheKey = "\(username)_\(password.hashValue)" as NSString

        // Check cache first (quantum optimization)
        if let cachedResult = authCache.object(forKey: cacheKey),
           !cachedResult.isExpired {
            return cachedResult
        }

        // Rate limiting check
        guard await rateLimiter.checkLimit(for: username) else {
            throw AuthenticationError.rateLimitExceeded
        }

        // Retrieve user with caching
        guard let user = try await getCachedUser(byUsername: username) else {
            throw AuthenticationError.invalidCredentials
        }

        // Verify password with optimized hashing
        guard try await passwordHasher.verifyOptimized(password: password, hash: user.passwordHash) else {
            throw AuthenticationError.invalidCredentials
        }

        // Generate JWT token
        let token = try await tokenManager.generateToken(for: user)
        let result = AuthenticationResult(
            user: user,
            token: token,
            expiresAt: Date().addingTimeInterval(3600)
        )

        // Cache result
        authCache.setObject(result, forKey: cacheKey)
        return result
    }

    /// Validate token with quantum-optimized caching
    public func validateToken(_ token: String) async throws -> User {
        let cacheKey = token as NSString

        // Check token validation cache
        if let isValid = tokenValidationCache.object(forKey: cacheKey), isValid {
            // Token is valid, get user from cache or validate
            if let cachedUser = userCache.object(forKey: "user_\(token)" as NSString) {
                return cachedUser
            }
        }

        let user = try await tokenManager.validateToken(token)

        // Cache validation result and user
        tokenValidationCache.setObject(true, forKey: cacheKey)
        userCache.setObject(user, forKey: "user_\(token)" as NSString)

        return user
    }

    /// Optimized token refresh
    public func refreshToken(_ expiredToken: String) async throws -> AuthenticationResult {
        let user = try await validateToken(expiredToken)
        let newToken = try await tokenManager.generateToken(for: user)

        let result = AuthenticationResult(
            user: user,
            token: newToken,
            expiresAt: Date().addingTimeInterval(3600)
        )

        // Update caches
        tokenValidationCache.setObject(false, forKey: expiredToken as NSString)
        tokenValidationCache.setObject(true, forKey: newToken as NSString)

        return result
    }

    // MARK: - Private Methods

    private func getCachedUser(byUsername username: String) async throws -> User? {
        let cacheKey = username as NSString

        if let cachedUser = userCache.object(forKey: cacheKey) {
            return cachedUser
        }

        let user = try await userStore.getUser(byUsername: username)
        if let user = user {
            userCache.setObject(user, forKey: cacheKey)
        }

        return user
    }
}

// MARK: - Optimized Dependencies

/// Optimized password hasher with quantum enhancements
public final class PasswordHasher {
    public static let shared = PasswordHasher()
    private let hashCache: NSCache<NSString, String>

    private init() {
        self.hashCache = NSCache<NSString, String>()
        self.hashCache.countLimit = 10000
    }

    public func hash(password: String) async throws -> String {
        let cacheKey = password as NSString
        if let cached = hashCache.object(forKey: cacheKey) {
            return cached
        }

        // Quantum-optimized hashing using CryptoKit
        let passwordData = Data(password.utf8)
        let hash = SHA256.hash(data: passwordData)
        let hashString = hash.compactMap { String(format: "%02x", $0) }.joined()

        hashCache.setObject(hashString, forKey: cacheKey)
        return hashString
    }

    public func verifyOptimized(password: String, hash: String) async throws -> Bool {
        let computedHash = try await self.hash(password: password)
        return computedHash == hash
    }
}
