name: SwiftWasm Web CI/CD

on:
  push:
    branches: [main]
    paths:
      - 'Projects/*/WebInterface/**'
      - '.github/workflows/swiftwasm-web-ci-cd.yml'
  pull_request:
    branches: [main]
    paths:
      - 'Projects/*/WebInterface/**'
  workflow_dispatch:
    inputs:
      project:
        description: 'Project to build and deploy'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - AvoidObstaclesGame
          - PlannerApp
          - MomentumFinance
          - HabitQuest
          - CodingReviewer
      environment:
        description: 'Deployment environment'
        required: false
        default: 'staging'
        type: choice
        options:
          - staging
          - production

jobs:
  validate-projects:
    name: Validate Web Projects
    runs-on: ubuntu-latest
    outputs:
      projects: ${{ steps.validate.outputs.projects }}
    steps:
      - uses: actions/checkout@v4

      - name: Validate Web Projects
        id: validate
        run: |
          echo "üîç Validating SwiftWasm web projects..."

          PROJECTS=("AvoidObstaclesGame" "PlannerApp" "MomentumFinance" "HabitQuest" "CodingReviewer")
          VALID_PROJECTS=()

          for project in "${PROJECTS[@]}"; do
            WEB_DIR="Projects/${project}/WebInterface"
            if [[ -d "$WEB_DIR" && -f "$WEB_DIR/Package.swift" ]]; then
              echo "‚úÖ ${project} has WebInterface setup"
              VALID_PROJECTS+=("$project")
            else
              echo "‚ö†Ô∏è  ${project} missing WebInterface or Package.swift"
            fi
          done

          # Output JSON array of valid projects
          printf -v joined '%s,' "${VALID_PROJECTS[@]}"
          echo "projects=[${joined%,}]" >> $GITHUB_OUTPUT

          echo "üìã Valid projects: ${VALID_PROJECTS[*]}"

  build-web-apps:
    name: Build Web App (${{ matrix.project }})
    runs-on: ubuntu-latest
    needs: validate-projects
    strategy:
      fail-fast: false
      matrix:
        project: ${{ fromJson(needs.validate-projects.outputs.projects) }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker
        run: |
          docker --version
          docker pull swiftwasm/swiftwasm:latest

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.docker-cache
          key: docker-swiftwasm-${{ matrix.project }}-${{ hashFiles('Projects/${{ matrix.project }}/WebInterface/Package.swift') }}
          restore-keys: docker-swiftwasm-${{ matrix.project }}-

      - name: Build SwiftWasm App
        run: |
          echo "üî® Building ${{ matrix.project }} WebAssembly app..."

          cd "Projects/${{ matrix.project }}/WebInterface"

          # Make build script executable
          chmod +x build_docker.sh

          # Build using Docker (avoids local toolchain issues)
          if ./build_docker.sh; then
            echo "‚úÖ ${{ matrix.project }} WebAssembly build successful"

            # Verify build artifacts
            if [[ -f "${{ matrix.project }}Web.wasm" && -f "${{ matrix.project }}Web.js" ]]; then
              echo "‚úÖ Build artifacts verified"
              ls -la ${{ matrix.project }}Web.*
            else
              echo "‚ùå Build artifacts missing"
              exit 1
            fi
          else
            echo "‚ùå ${{ matrix.project }} WebAssembly build failed"
            exit 1
          fi

      - name: Validate Web Assets
        run: |
          echo "üîç Validating web assets for ${{ matrix.project }}..."

          cd "Projects/${{ matrix.project }}/WebInterface"

          # Check for required files
          REQUIRED_FILES=(
            "${{ matrix.project }}Web.wasm"
            "${{ matrix.project }}Web.js"
            "index.html"
          )

          for file in "${REQUIRED_FILES[@]}"; do
            if [[ -f "$file" ]]; then
              echo "‚úÖ $file found"
            else
              echo "‚ùå $file missing"
              exit 1
            fi
          done

          # Check file sizes (WASM should be reasonable)
          WASM_SIZE=$(stat -f%z "${{ matrix.project }}Web.wasm" 2>/dev/null || stat -c%s "${{ matrix.project }}Web.wasm")
          if [[ $WASM_SIZE -gt 1000 ]]; then  # At least 1KB
            echo "‚úÖ WASM file size: $WASM_SIZE bytes"
          else
            echo "‚ùå WASM file suspiciously small: $WASM_SIZE bytes"
            exit 1
          fi

      - name: Test Web App Locally
        run: |
          echo "üß™ Testing ${{ matrix.project }} web app locally..."

          cd "Projects/${{ matrix.project }}/WebInterface"

          # Start local web server in background
          python3 -m http.server 8000 &
          SERVER_PID=$!

          # Wait for server to start
          sleep 2

          # Test if server is responding
          if curl -f http://localhost:8000/index.html --max-time 10; then
            echo "‚úÖ Web server responding"
          else
            echo "‚ùå Web server not responding"
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi

          # Check if WASM file is accessible
          if curl -f http://localhost:8000/${{ matrix.project }}Web.wasm --max-time 10; then
            echo "‚úÖ WASM file accessible"
          else
            echo "‚ùå WASM file not accessible"
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi

          # Cleanup
          kill $SERVER_PID 2>/dev/null || true

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.project }}-web-build
          path: |
            Projects/${{ matrix.project }}/WebInterface/${{ matrix.project }}Web.wasm
            Projects/${{ matrix.project }}/WebInterface/${{ matrix.project }}Web.js
            Projects/${{ matrix.project }}/WebInterface/index.html
            Projects/${{ matrix.project }}/WebInterface/demo.html

  cross-platform-validation:
    name: Cross-Platform Browser Validation
    runs-on: ubuntu-latest
    needs: build-web-apps
    strategy:
      fail-fast: false
      matrix:
        browser: [chrome, firefox]
        project: ${{ fromJson(needs.validate-projects.outputs.projects) }}
    steps:
      - uses: actions/checkout@v4

      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.project }}-web-build
          path: web-assets

      - name: Set up Node.js for Testing
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm install playwright
          npx playwright install ${{ matrix.browser == 'chrome' && 'chromium' || matrix.browser }}

      - name: Run Browser Compatibility Tests
        run: |
          echo "üåê Testing ${{ matrix.project }} on ${{ matrix.browser }}..."

          # Create test script
          cat > test_browser.js << 'EOF'
          const { chromium, firefox } = require('playwright');

          async function testWebApp() {
            const browserType = process.env.BROWSER === 'firefox' ? firefox : chromium;
            const browser = await browserType.launch();
            const page = await browser.newPage();

            try {
              // Start local server
              const { spawn } = require('child_process');
              const server = spawn('python3', ['-m', 'http.server', '8000'], { cwd: 'web-assets' });

              // Wait for server to start
              await new Promise(resolve => setTimeout(resolve, 2000));

              // Navigate to the web app
              await page.goto('http://localhost:8000/index.html', { waitUntil: 'networkidle' });

              // Wait for page to load
              await page.waitForTimeout(3000);

              // Check if the page loaded without critical errors
              const errors = [];
              page.on('pageerror', error => errors.push(error.message));

              // Check for WebAssembly loading
              const wasmLoaded = await page.evaluate(() => {
                return typeof WebAssembly !== 'undefined';
              });

              if (!wasmLoaded) {
                throw new Error('WebAssembly not supported in browser');
              }

              // Check if the app initialized (look for loading indicator or game canvas)
              const hasContent = await page.evaluate(() => {
                const loading = document.getElementById('loading');
                const canvas = document.querySelector('canvas');
                const gameContainer = document.getElementById('game-container');
                return !!(loading || canvas || gameContainer || document.body.textContent.trim());
              });

              if (!hasContent) {
                throw new Error('Web app content not loaded');
              }

              // Check for console errors
              if (errors.length > 0) {
                console.warn('Browser console errors:', errors);
              }

              console.log('‚úÖ Web app loaded successfully in ' + process.env.BROWSER);

              return true;

            } catch (error) {
              console.error('‚ùå Web app test failed:', error.message);
              throw error;
            } finally {
              await browser.close();
              if (server) server.kill();
            }
          }

          testWebApp().catch(console.error);
          EOF

          # Set browser environment variable
          export BROWSER=${{ matrix.browser }}

          # Run the test
          if node test_browser.js; then
            echo "‚úÖ ${{ matrix.project }} compatible with ${{ matrix.browser }}"
          else
            echo "‚ùå ${{ matrix.project }} has issues with ${{ matrix.browser }}"
            exit 1
          fi

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-web-apps, cross-platform-validation]
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event.inputs.environment == 'staging')
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - name: Download All Build Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: '*-web-build'
          path: staging-deployment

      - name: Prepare Staging Deployment
        run: |
          echo "üì¶ Preparing staging deployment..."

          # Create directory structure
          mkdir -p staging-deployment/apps

          # Organize artifacts by project
          for artifact_dir in staging-deployment/*-web-build; do
            if [[ -d "$artifact_dir" ]]; then
              project_name=$(basename "$artifact_dir" | sed 's/-web-build//')
              mkdir -p "staging-deployment/apps/$project_name"
              cp -r "$artifact_dir"/* "staging-deployment/apps/$project_name/" 2>/dev/null || true
            fi
          done

          # Create staging index page
          cat > staging-deployment/index.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Quantum Workspace - Web Apps (Staging)</title>
              <style>
                  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
                  .container { max-width: 1200px; margin: 0 auto; }
                  .header { text-align: center; margin-bottom: 40px; }
                  .apps-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
                  .app-card { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); transition: transform 0.2s; }
                  .app-card:hover { transform: translateY(-2px); }
                  .app-title { font-size: 1.2em; font-weight: bold; margin-bottom: 10px; color: #333; }
                  .app-description { color: #666; margin-bottom: 15px; }
                  .app-link { display: inline-block; background: #007acc; color: white; padding: 8px 16px; border-radius: 6px; text-decoration: none; }
                  .app-link:hover { background: #005aa3; }
                  .staging-badge { background: #ff6b35; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8em; margin-bottom: 10px; display: inline-block; }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1>üöÄ Quantum Workspace Web Apps</h1>
                      <div class="staging-badge">STAGING ENVIRONMENT</div>
                      <p>Latest builds from main branch - for testing and validation</p>
                  </div>

                  <div class="apps-grid" id="apps-grid">
                      <!-- Apps will be loaded here -->
                  </div>
              </div>

              <script>
                  const apps = [
                      {
                          name: 'Avoid Obstacles Game',
                          path: 'apps/AvoidObstaclesGame/index.html',
                          description: 'HTML5 WebAssembly game built with Swift - avoid obstacles and achieve high scores!',
                          icon: 'üéÆ'
                      },
                      {
                          name: 'Planner App',
                          path: 'apps/PlannerApp/index.html',
                          description: 'Task and goal management with AI-powered prioritization',
                          icon: 'üìÖ'
                      },
                      {
                          name: 'Momentum Finance',
                          path: 'apps/MomentumFinance/index.html',
                          description: 'Financial tracking and budgeting with advanced analytics',
                          icon: 'üí∞'
                      },
                      {
                          name: 'Habit Quest',
                          path: 'apps/HabitQuest/index.html',
                          description: 'Gamified habit tracking with AI insights and rewards',
                          icon: 'üéØ'
                      },
                      {
                          name: 'Coding Reviewer',
                          path: 'apps/CodingReviewer/index.html',
                          description: 'AI-powered code review and analysis tool',
                          icon: 'üë®‚Äçüíª'
                      }
                  ];

                  const appsGrid = document.getElementById('apps-grid');
                  apps.forEach(app => {
                      const appCard = document.createElement('div');
                      appCard.className = 'app-card';
                      appCard.innerHTML = `
                          <div class="app-title">${app.icon} ${app.name}</div>
                          <div class="app-description">${app.description}</div>
                          <a href="${app.path}" class="app-link">Launch App</a>
                      `;
                      appsGrid.appendChild(appCard);
                  });
              </script>
          </body>
          </html>
          EOF

          echo "‚úÖ Staging deployment prepared"

      - name: Deploy to Staging Environment
        run: |
          echo "üöÄ Deploying to staging environment..."

          # For now, create deployment archive
          # In production, this would deploy to a staging server
          cd staging-deployment
          tar -czf ../web-apps-staging-${{ github.run_id }}.tar.gz .

          echo "üì¶ Staging deployment archive created: web-apps-staging-${{ github.run_id }}.tar.gz"

      - name: Upload Staging Deployment
        uses: actions/upload-artifact@v4
        with:
          name: web-apps-staging-deployment
          path: web-apps-staging-${{ github.run_id }}.tar.gz

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'
    environment: production
    steps:
      - name: Download Staging Deployment
        uses: actions/download-artifact@v4
        with:
          name: web-apps-staging-deployment

      - name: Extract Deployment Archive
        run: |
          tar -xzf web-apps-staging-${{ github.run_id }}.tar.gz
          ls -la

      - name: Deploy to Production
        run: |
          echo "üéâ Deploying to production environment..."
          echo "Production deployment would happen here"
          echo "This could integrate with:"
          echo "- GitHub Pages"
          echo "- Netlify/Vercel"
          echo "- AWS S3/CloudFront"
          echo "- Azure Static Web Apps"
          echo "- Custom web servers"

          # For demonstration, just validate the deployment package
          if [[ -f "index.html" && -d "apps" ]]; then
            echo "‚úÖ Production deployment package validated"
            echo "üìä Deployment summary:"
            echo "   - Main index page: ‚úÖ"
            echo "   - Apps directory: ‚úÖ"
            find apps -name "*.wasm" | wc -l | xargs echo "   - WebAssembly files:"
            find apps -name "*.html" | wc -l | xargs echo "   - HTML files:"
          else
            echo "‚ùå Production deployment package invalid"
            exit 1
          fi

  update-deployment-status:
    name: Update Deployment Status
    runs-on: ubuntu-latest
    needs: [validate-projects, build-web-apps, cross-platform-validation, deploy-staging]
    if: always()
    steps:
      - name: Generate Deployment Report
        run: |
          echo "# üöÄ SwiftWasm Web CI/CD Report" >> deployment_report.md
          echo "" >> deployment_report.md
          echo "**Run ID:** ${{ github.run_id }}" >> deployment_report.md
          echo "**Timestamp:** $(date -Iseconds)" >> deployment_report.md
          echo "**Triggered by:** ${{ github.event_name }}" >> deployment_report.md
          echo "" >> deployment_report.md

          echo "## üìä Build Results" >> deployment_report.md
          echo "- **Validation:** ${{ needs.validate-projects.result }}" >> deployment_report.md
          echo "- **Build:** ${{ needs.build-web-apps.result }}" >> deployment_report.md
          echo "- **Cross-platform:** ${{ needs.cross-platform-validation.result }}" >> deployment_report.md
          echo "- **Staging:** ${{ needs.deploy-staging.result }}" >> deployment_report.md
          echo "" >> deployment_report.md

          # Count successful projects
          PROJECTS=("AvoidObstaclesGame" "PlannerApp" "MomentumFinance" "HabitQuest" "CodingReviewer")
          SUCCESSFUL_BUILDS=0

          for project in "${PROJECTS[@]}"; do
            if [[ "${{ needs.build-web-apps.result }}" == "success" ]]; then
              ((SUCCESSFUL_BUILDS++))
            fi
          done

          echo "## üéØ Success Metrics" >> deployment_report.md
          echo "- **Projects Built:** $SUCCESSFUL_BUILDS/5" >> deployment_report.md
          echo "- **WebAssembly Apps:** $SUCCESSFUL_BUILDS" >> deployment_report.md
          echo "- **Browser Compatibility:** ${{ needs.cross-platform-validation.result == 'success' && '‚úÖ Chrome & Firefox' || '‚ùå Issues detected' }}" >> deployment_report.md
          echo "" >> deployment_report.md

          if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "## üåê Deployment Status" >> deployment_report.md
            echo "‚úÖ **Staging deployment successful**" >> deployment_report.md
            echo "- All web apps deployed to staging environment" >> deployment_report.md
            echo "- Cross-browser compatibility validated" >> deployment_report.md
            echo "- Ready for production deployment" >> deployment_report.md
          else
            echo "## ‚ö†Ô∏è Deployment Status" >> deployment_report.md
            echo "‚ùå **Deployment issues detected**" >> deployment_report.md
            echo "- Check build logs for details" >> deployment_report.md
            echo "- Validate WebAssembly compilation" >> deployment_report.md
          fi

          echo "" >> deployment_report.md
          echo "---" >> deployment_report.md
          echo "*Generated by SwiftWasm Web CI/CD Pipeline*" >> deployment_report.md

      - name: Upload Deployment Report
        uses: actions/upload-artifact@v4
        with:
          name: swiftwasm-deployment-report
          path: deployment_report.md

      - name: Notify on Failure
        if: failure()
        run: |
          echo "‚ùå SwiftWasm Web CI/CD failed"
          echo "Check the deployment report for details"
          # In production, this could send notifications to Slack, Discord, etc.</content>
<parameter name="filePath">/Users/danielstevens/Desktop/Quantum-workspace/.github/workflows/swiftwasm-web-ci-cd.yml